<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="/css/styles.css"/>
  </head>
  <body>
    <header>
      <nav>
        <ol class="logo">
          <li>
            <a href="/">
              <img src="/media/brightdigit-name.svg"/>
            </a>
          </li>
        </ol>
        <ol class="menu">
          <li>
            <a href="/services">Services</a>
          </li>
          <li>
            <a href="/products">Products</a>
          </li>
          <li>
            <a href="/articles">Articles</a>
          </li>
          <li>
            <a href="/development">Development</a>
          </li>
        </ol>
        <ol class="menu">
          <li>
            <a href="/podcast">Podcast</a>
          </li>
          <li>
            <a href="/newsletters">Newsletters</a>
          </li>
          <li>
            <a href="/sponsorship">Sponsorship</a>
          </li>
          <li>
            <a href="/about">About</a>
          </li>
        </ol>
        <ol class="more">
          <li>
            <a href="/#menu">Menu</a>
          </li>
        </ol>
      </nav>
    </header>
    <main>
      <article>
        <div class="content"><p><a href="https://learningswift.brightdigit.com/combine-corelocation-publishers-delegates/">In our previous post,</a> we talked about how to build a Publisher Factory or Publicist. In this post, we'll talk about how receiving and handling Events in our ObservableObject from our new Publicist class.</p><ul><li><a href="https://learningswift.brightdigit.com/combine-corelocation-publishers-delegates/">Creating Publishers from Delegates</a></li><li><strong>Using Function Reactive Programming to Transform Values</strong></li><li><a href="https://learningswift.brightdigit.com/combine-corelocation-swiftui-delegates/">Understanding flatMap and Built-In Publishers (Part 3)</a></li></ul><h2>Receiving and Handling Events in our ObservableObject</h2><p>Our <code>ObservableObject</code> needs to accomplish a few things to update our SwiftUI while listening to our <em>CoreLocation</em> publishers. First of all we need to:</p><ol><li>Create the CoreLocation Manager</li><li>Create our CoreLocation Publicist</li><li>Connect the Publicist as the Delegate of the Manager</li><li>Create our Authorization Status and Location Publishers</li></ol><p>With this in mind, here is how that looks:</p><pre><code><span class="keyword">class</span> CoreLocationObject: <span class="type">ObservableObject</span> {
  <span class="keyword">@Published var</span> authorizationStatus = <span class="type">CLAuthorizationStatus</span>.<span class="property">notDetermined</span>
  <span class="keyword">@Published var</span> location: <span class="type">CLLocation</span>?

  <span class="keyword">let</span> manager: <span class="type">CLLocationManager</span>
  <span class="keyword">let</span> publicist: <span class="type">CLLocationManagerCombineDelegate</span>

  <span class="keyword">var</span> cancellables = [<span class="type">AnyCancellable</span>]()

  <span class="keyword">init</span>() {
    <span class="keyword">let</span> manager = <span class="type">CLLocationManager</span>()
    <span class="keyword">let</span> publicist = <span class="type">CLLocationManagerPublicist</span>()

    manager.<span class="property">delegate</span> = publicist

    <span class="keyword">self</span>.<span class="property">manager</span> = manager
    <span class="keyword">self</span>.<span class="property">publicist</span> = publicist

    <span class="keyword">let</span> authorizationPublisher = publicist.<span class="call">authorizationPublisher</span>()
    <span class="keyword">let</span> locationPublisher = publicist.<span class="call">locationPublisher</span>()
  ...
</code></pre><p>Next, we can actually deal with receiving and handling events from our Publishers. Firstly, let's deal with the <code>CLAuthorizationStatus</code>.</p><h2>Receiving and Handling Events with Sink and Assign</h2><p>As far the CLAuthorizationStatus, there are two things we need to do when the authorization status changes:</p><ul><li>Trigger Location Update when <code>CLAuthorizationStatus</code> is valid</li><li>Assign the <code>CLAuthorizationStatus</code> to our <code>@Published CLAuthorizationStatus</code> Property <code>authorizationStatus</code></li></ul><h3>Using Sink For Calling Methods</h3><p>Let's first deal with triggering location updates by creating a method to begin those updates:</p><pre><code><span class="keyword">class</span> CoreLocationObject: <span class="type">ObservableObject</span> {
  <span class="keyword">@Published var</span> authorizationStatus = <span class="type">CLAuthorizationStatus</span>.<span class="property">notDetermined</span>
  <span class="keyword">@Published var</span> location: <span class="type">CLLocation</span>?

  <span class="keyword">let</span> manager: <span class="type">CLLocationManager</span>

...

  <span class="keyword">func</span> beginUpdates(<span class="keyword">_</span> authorizationStatus: <span class="type">CLAuthorizationStatus</span>) {
    <span class="keyword">if</span> authorizationStatus == .<span class="dotAccess">authorizedAlways</span> || authorizationStatus == .<span class="dotAccess">authorizedWhenInUse</span> {
      manager.<span class="call">startUpdatingLocation</span>()
    }
  }
}
</code></pre><p>Our <code>beginUpdate</code> method will take in the <code>CLAuthorizedStatus</code> as it comes in from the <code>Publisher</code>. As a result, **if the status allows for location update then it calls <code>startUpdatingLocation</code> on the</p><p><code>CLLocationManager</code>.**</p><p>With this in mind, let's connect the <code>authorizationPublisher</code> to the</p><p><code>beginUpdates</code> method:</p><pre><code><span class="keyword">class</span> CoreLocationObject: <span class="type">ObservableObject</span> {

  ...
  <span class="keyword">var</span> cancellables = [<span class="type">AnyCancellable</span>]()

  <span class="keyword">init</span>() {
    <span class="keyword">let</span> publicist = <span class="type">CLLocationManagerPublicist</span>()
   
    ...
    
    <span class="keyword">let</span> authorizationPublisher = publicist.<span class="call">authorizationPublisher</span>()

    <span class="comment">// trigger an update when authorization changes</span>
    authorizationPublisher
      .<span class="call">sink</span>(receiveValue: beginUpdates)
      .<span class="call">store</span>(in: &amp;cancellables)
  ...
</code></pre><p>In this case, we are using <code>sink</code> and passing a reference to our new method. <code>sink</code> returns a <code>Cancellable</code> which we'll need to make sure is disposed properly. Therefore, we use <code>.store</code> to make sure that</p><p><code>Cancellable</code> is stored correctly in our `cancelables` <code>Array</code>.</p><p>Now we should be correctly starting location updates when permission is granted. Next, let's store the <code>CLAuthorizationStatus</code> in our</p><p><code>@Published</code> property so we can display it in our SwiftUI view.</p><h3>Receiving and Handling Events with Assign (in iOS 13 and iOS 14)</h3><p><strong>One of the first things you learn as an iOS developer using UIKit is the importance of making UI updates on the main dispatch queue.</strong> In other words, failure to do this results in incorrect UI updates or even crashing your app. Likewise, in SwiftUI, you need to specify UI updates on the main dispatch queue. Therefore we can use <code>receive</code> to ensure updates are on the main <code>DispatchQueue</code>.</p><pre><code>...
      authorizationPublisher
        <span class="comment">// since this is used in the UI,
        //  it needs to be on the main DispatchQueue</span>
        .<span class="call">receive</span>(on: <span class="type">DispatchQueue</span>.<span class="property">main</span>)
    ...
</code></pre><p>As far as assigning we have a few options, we can stick with <code>sink</code> to assign our value the published property:</p><pre><code>...
      authorizationPublisher
        <span class="comment">// since this is used in the UI,
        //  it needs to be on the main DispatchQueue</span>
        .<span class="call">receive</span>(on: <span class="type">DispatchQueue</span>.<span class="property">main</span>)
    .<span class="call">sink</span>(receiveValue: {
          <span class="keyword">self</span>.<span class="property">authorizationStatus</span> = $0
        })
...
</code></pre><p>However, we could simplify this with <code>assign</code>:</p><pre><code>...
      authorizationPublisher
        <span class="comment">// since this is used in the UI,
        //  it needs to be on the main DispatchQueue</span>
        .<span class="call">receive</span>(on: <span class="type">DispatchQueue</span>.<span class="property">main</span>)
        <span class="comment">// store the value in the authorizationStatus property</span>
        .<span class="call">assign</span>(to: &amp;$authorizationStatus)
...
</code></pre><p><a href="https://developer.apple.com/documentation/combine/publisher/assign(to:">This new assign available in all the new 2020 OSes (iOS 14, macOS 11, watchOS 7, etc...)</a>) allows us to assign the value directly to the publisher using the &amp; (for an in-out parameter) and $ (for the publisher).</p><p>Additionally no <code>Cancellable</code> is returned and therefore not needed to be stored.</p><h2>Sink vs Assign when Receiving and Handling Events</h2><p>::: {.wp-block-image} <img src="https://learningswift.brightdigit.com/wp-content/uploads/sites/2/2020/08/Combine-ing-the-Old-with-the-New.001-1024x204.png"/>{.wp-image-1062} :::</p><p>Choosing the correct method can be difficult but here's some guidelines:</p><ul><li>If you are doing some additional logic besides just assigning a value, use <code>sink</code></li><li>For just assigning a value, use <code>assign</code></li><li>When assigning a value which is being used directly by the UI (i.e. UIKit View or SwiftUI View), use <a href="https://developer.apple.com/documentation/combine/publisher/receive(on:options:"><code>.receive(on: DispatchQueue.main)</code></a>)</li><li>Make sure when using <code>sink</code> or the <a href="https://developer.apple.com/documentation/combine/publisher/assign(to:on:">2019 version of <code>assign</code></a>) (i.e. <code>assign(to:on:)</code>), save the resulting <code>Cancellable</code> by <a href="https://developer.apple.com/documentation/combine/anycancellable/store(in:">using <code>.store</code></a>-6cr9i)</li><li>When there's more than one <code>AnyCancellable</code> property, consider using a <a href="https://developer.apple.com/documentation/combine/anycancellable/store(in:"><code>Set</code> or <code>Array</code> for storing the <code>Cancellables</code></a>-3hyxs)</li></ul><p>In the next blog post, I'll cover some more advance functional programming techniques in Combine when we transform our <code>CLLocation</code> to something more useful.</p></div>
        <span>Tagged with: </span>
      </article>
    </main>
    <footer>
      <div class="address">5859 W Saginaw #182 Lansing MI 48917</div>
      <div class="copyright">© Bright Digit, LLC 2021</div>
    </footer>
  </body>
</html>