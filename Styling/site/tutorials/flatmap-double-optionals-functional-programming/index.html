<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="/css/styles.css"/>
  </head>
  <body>
    <header>
      <nav>
        <ol class="logo">
          <li>
            <a href="/">
              <img src="/media/brightdigit-name.svg"/>
            </a>
          </li>
        </ol>
        <ol class="menu">
          <li>
            <a href="/services">Services</a>
          </li>
          <li>
            <a href="/products">Products</a>
          </li>
          <li>
            <a href="/articles">Articles</a>
          </li>
          <li>
            <a href="/development">Development</a>
          </li>
        </ol>
        <ol class="menu">
          <li>
            <a href="/podcast">Podcast</a>
          </li>
          <li>
            <a href="/newsletters">Newsletters</a>
          </li>
          <li>
            <a href="/sponsorship">Sponsorship</a>
          </li>
          <li>
            <a href="/about">About</a>
          </li>
        </ol>
        <ol class="more">
          <li>
            <a href="/#menu">Menu</a>
          </li>
        </ol>
      </nav>
    </header>
    <main>
      <article>
        <div class="content"><p>A while ago <a href="https://learningswift.brightdigit.com/understanding-optionals-in-swift/">I did an article on the basics of <strong>Optionals</strong></a> and how they work in Swift. However, it seems there's some confusion as to how one particular method works in Swift when it comes to a collection of <strong>Optionals</strong>: <em>flatMap</em>.</p><p>With all the talk regarding <em>flattening the curve</em>, today I want to explain exactly what it means to flatten in the context of functional programming. Additionally, it not only can be used on <strong>Arrays</strong> but single <strong>Optionals</strong> as well. In the end, using them correctly will make your code easier to read.</p><h2>flatMap vs map and Generic</h2><p>Before we dive into what <strong><em>flatMap</em></strong> does, let's talk about <strong>what flatten actually means</strong>. Most importantly, <em>flatMap</em> is typically a <em>map</em> coupled with a <em>flatten</em> operation. The flatten operation typically is used in the context of <strong>Generics</strong>, such as <strong>Arrays</strong>, <strong>Promises</strong>, <strong>Publishers</strong>, and even <strong>Optionals</strong> (<em>remember Optionals are Generic enums</em>).</p><p>Let's create our own Generic to show how this would work:</p><pre><code><span class="keyword">struct</span> Foo&lt;Value&gt; {
  <span class="keyword">let</span> value : <span class="type">Value</span>
}
</code></pre><p>Here's a simple Generic <code>Foo</code> which contains a value. Therefore, let's add a simple map function in case the developer wants to convert the value into something else:</p><pre><code><span class="keyword">extension</span> <span class="type">Foo</span> {
  <span class="keyword">func</span> map&lt;Output&gt;( <span class="keyword">_</span> callback: (<span class="type">Value</span>) -&gt; (<span class="type">Output</span>) ) -&gt; <span class="type">Foo</span>&lt;<span class="type">Output</span>&gt; {
    <span class="keyword">let</span> output = <span class="call">callback</span>(<span class="keyword">self</span>.<span class="property">value</span>)
    <span class="keyword">return</span> <span class="type">Foo</span>&lt;<span class="type">Output</span>&gt;(value : output)
  }
}
</code></pre><p>Now we have simple map method which works similar to others, where the developer can convert the <code>Foo</code> into some other type. For instance:</p><pre><code><span class="keyword">let</span> firstItem = <span class="type">Foo</span>(value: <span class="number">3.0</span>)
<span class="keyword">let</span> secondItem = firstItem.<span class="property">map</span>{ $0.<span class="property">description</span> }
</code></pre><p>In this case, we have a <code>Foo&lt;Double&gt;</code> which is converted into a</p><p><code>Foo&lt;String&gt;</code> using our new map function.</p><p>However there are instances where this can cause issues.</p><h3>Arrays of Arrays</h3><p>The simplest case where map doesn't quite do what you want would be when you need a flat list. For instance, let's say you want to get a flat list of books from their authors:</p><pre><code><span class="keyword">struct</span> Author {
  ...
  <span class="keyword">let</span> name : <span class="type">String</span>
  <span class="keyword">let</span> books : [<span class="type">String</span>]
}
</code></pre><p>Then you have a list of authors and their books in JSON:</p><pre><code>[
  {
    <span class="string">"Franz Kafka"</span>: [
      <span class="string">"Stories"</span>,
      <span class="string">"The Trial"</span>,
      <span class="string">"The Castle"</span>
    ]
  },
  {
    <span class="string">"Fyodor Dostoevsky"</span>: [
      <span class="string">"Crime and Punishment"</span>,
      <span class="string">"The Idiot"</span>,
      <span class="string">"The Possessed"</span>,
      <span class="string">"The Brothers Karamazov"</span>
    ]
  },
  {
    <span class="string">"Leo Tolstoy"</span>: [
      <span class="string">"War and Peace"</span>,
      <span class="string">"Anna Karenina"</span>,
      <span class="string">"The Death of Ivan Ilyich"</span>
    ]
  },
  {
    <span class="string">"William Shakespeare"</span>: [
      <span class="string">"Hamlet"</span>,
      <span class="string">"King Lear"</span>,
      <span class="string">"Othello"</span>
    ]
  }
]
</code></pre><p>Unfortunately, map would only return an <strong>Array of an Array</strong> or <strong>Jagged Array</strong> of books (i.e. <code>[[String]]</code>):</p><pre><code><span class="keyword">let</span> authors : [<span class="type">Author</span>] = ...
<span class="keyword">let</span> books : [[<span class="type">String</span>]] = authors.<span class="call">map</span> {
  $0.<span class="property">books</span>
}
</code></pre><p>As a result, we get:</p><pre><code>[
  [
    <span class="string">"Stories"</span>,
    <span class="string">"The Trial"</span>,
    <span class="string">"The Castle"</span>
  ],
  [
      <span class="string">"Crime and Punishment"</span>,
      <span class="string">"The Idiot"</span>,
      <span class="string">"The Possessed"</span>,
      <span class="string">"The Brothers Karamazov"</span>
   ],...
</code></pre><p>However, this is where a <strong><em>flatMap</em></strong> would be useful:</p><pre><code><span class="keyword">let</span> authors : [<span class="type">Author</span>] = ...
<span class="keyword">let</span> books : [<span class="type">String</span>] = authors.<span class="call">flatMap</span> {
  $0.<span class="property">books</span>
}
</code></pre><p>Now, rather than returning an Array of Arrays, <em>flatMap</em> automatically flattens the result. Not only does this work with Arrays but other <strong>Generics</strong> as well. A great example of this is in use with asynchronous methods.</p><p>If you are interested in learning more about how SwiftNIO and Google Futures does this with Promises and Futures, check out my <a href="https://learningswift.brightdigit.com/asynchronous-multi-threaded-parallel-world-of-swift/">article on asynchronous programming here.</a> Additionally Combine, which is frequently used with SwiftUI, contains a <a href="https://developer.apple.com/documentation/combine/publisher/3204718-map">map</a> and <a href="https://developer.apple.com/documentation/combine/publisher/3204712-flatmap">flatMap</a> for its Publishers as well.</p><p>Besides Arrays, Promises, and Combine Publishers, there was one other Generic we are forgetting to cover which often can cause issues. If you have run into the elusive <code>Type??</code> value then you have probably run into an instance where <strong><em>flatMap</em></strong> should be used on <strong>Optionals</strong>.</p><h2>flatMap and the elusive Double Optional??</h2><p>So let's say we have a generic function which returns an optional:</p><pre><code><span class="keyword">func</span> maybe&lt;T&gt;(<span class="keyword">_</span> value: <span class="type">T</span>) -&gt; <span class="type">T</span>? {
  <span class="type">Bool</span>.<span class="call">random</span>() ? value : <span class="keyword">nil</span>
}
</code></pre><p>Then you've created a optional value:</p><pre><code><span class="keyword">let</span> optionalValue : <span class="type">Int</span>? = <span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">0</span>...<span class="number">10</span>)
</code></pre><p>Next, you decide to call that function which returns an optional on the option value and you end up with something that makes very little sense:</p><pre><code><span class="keyword">let</span> optionalOptional : <span class="type">Int</span>?? = <span class="call">maybe</span>(optionalValue)
</code></pre><p>What is an <code>Int??</code>...?</p><p>As stated earlier <strong>an Optional is really another Generic type.</strong> Here's a small snippet of the Generic Enumeration behind the scenes:</p><pre><code><span class="keyword">public enum</span> Optional&lt;Wrapped&gt; {
    <span class="keyword">case</span> none
    <span class="keyword">case</span> some(<span class="type">Wrapped</span>)
}
</code></pre><p>As you can see the '?' is simply syntactic sugar. So for instance an</p><p><code>Int?</code> is really an <code>Optional&lt;Int&gt;</code>. Therefore, we can surmise that an</p><p><code>Int??</code> is really a <code>Optional&lt;Optional&lt;Int&gt;&gt;</code>.</p><p>Therefore, we need to make sure that our result is flattened in order to use it. Luckily, <strong>Optional</strong> provides a <strong><em>flatMap</em></strong> function as well. For this reason, we can use <a href="https://developer.apple.com/documentation/swift/optional/1540500-flatmap"><code>Optional.flatMap</code></a> to fix our result:</p><pre><code><span class="keyword">let</span> betterOptionalValue : <span class="type">Int</span>? = optionalValue.<span class="call">flatMap</span>(<span class="call">maybe</span>(<span class="keyword">_</span>:))
</code></pre><p>By using <strong><em>flatMap</em></strong>, it flattens the result to return a <em>single</em> <strong>Optional</strong>. It's important to note, that <code>optionalValue</code> does not contain the <code>?</code> suffix since we want to call <strong><em>flatMap</em></strong> on</p><p><code>Optional&lt;Int&gt;</code> as opposed to Int. Likewise, <strong>Optional</strong> also contains a map function for when your method will return a non-optional value and does not require flattening.</p><h3>flatMap, parsing, and conversion</h3><p>There are a few use cases where <strong><em>flatMap</em></strong> on an <strong>Optional</strong> are useful. For instance, when you are parsing a value, there are cases where you wish to throw an error depending whether the value is invalid or missing (i.e. <code>nil</code>). However in some instances, you don't care whether the value is invalid or <code>nil</code> and want to just return <code>nil</code> if it fails. In this case, <strong><em>flatMap</em></strong> fits perfectly well:</p><pre><code><span class="keyword">func</span> parse (<span class="keyword">_</span> rawValue : <span class="type">RawType</span>) -&gt; <span class="type">ParsedType</span>?

<span class="keyword">let</span> parsedValue = optionalRawValue.<span class="call">flatMap</span>(parse)
</code></pre><p>For instance, parsing UUID from a String, rather than:</p><pre><code><span class="keyword">let</span> uuid : <span class="type">UUID</span>?

<span class="keyword">if let</span> uuidString = dictionary[<span class="string">"VCS_UUID"</span>] {
  uuid = <span class="type">UUID</span>(uuidString: uuidString)
} <span class="keyword">else</span> {
  uuid = <span class="keyword">nil</span>
}
</code></pre><p>... we can use:</p><pre><code><span class="keyword">let</span> uuid = dictionary[<span class="string">"VCS_UUID"</span>].<span class="call">flatMap</span>(<span class="type">UUID</span>.<span class="keyword">init</span>(uuidString:))
</code></pre><p>Besides parsing, I've used <strong><em>flatMap</em></strong> in instances where I need to convert a successful <code>Result</code> or value to a SwiftUI <code>View</code> as well:</p><pre><code>   <span class="keyword">var</span> iconImage: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="keyword">return self</span>.<span class="property">icon</span>.<span class="call">flatMap</span> { icon <span class="keyword">in
      guard case let</span> .<span class="call">image</span>(name) = icon <span class="keyword">else</span> {
        <span class="keyword">return nil</span>
      }
      <span class="keyword">return</span> name
    }.<span class="call">map</span> {
      <span class="type">Image</span>($0).<span class="call">renderingMode</span>(.<span class="dotAccess">template</span>)
    }
  }
</code></pre><p>In this case if the <code>self</code> <code>View</code> contains an <code>icon</code> with the case</p><p><code>image</code> then use the <code>name</code> and create templated <code>Image</code> for the <code>View</code>.</p><p>While there are instances where <strong><em>flatMap</em></strong> is useful, more often than not you may just wish to filter the <strong>Optional</strong> results from a map operation. This is where <strong><em>compactMap</em></strong> comes in.</p><h2>flatMap vs compactMap</h2><p>In many instances, you probably want simply remove Optionals from your Array or having a map return only non-Optional values. Before Swift 4.1, there was only one method for doing this as well as the traditional <strong><em>flatMap</em></strong> mentioned previously. Unfortunately as stated in <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0187-introduce-filtermap.md">the implemented proposal,</a> this caused much confusion. Therefore <strong><em>compactMap</em></strong> was added in Swift 4.1.</p><p>While <strong><em>flatMap</em></strong> concerns the returning of a flat Array of values, <strong><em>compactMap</em></strong> is specifically for instances where you need to make sure the Array returned contains no Optional values. In effect, <strong>if the closure for each item can return multiple items then a flatMap is right; otherwise if the closure can return either no items (i.e. nil) or one then compactMap makes the most sense.</strong></p><p>So for example, if we have <code>Node</code> struct and an Array of optional Nodes:</p><pre><code><span class="keyword">struct</span> Node&lt;Value&gt; {
  <span class="keyword">let</span> value : <span class="type">Value</span>
  <span class="keyword">let</span> children : [<span class="type">Node</span>&lt;<span class="type">Value</span>&gt;]
}

<span class="keyword">let</span> items : [<span class="type">Node</span>&lt;<span class="type">Int</span>&gt;?]
</code></pre><p>Therefore, let's see what happens when we use a combination of <strong><em>flatMap</em></strong> and <strong><em>compactMap</em></strong> in various ways:</p><pre><code><span class="comment">// returns an array with no Optionals</span>
<span class="keyword">let</span> array : [<span class="type">Node</span>&lt;<span class="type">Int</span>&gt;] = items.<span class="property">compactMap</span>{ $0 }

<span class="comment">// returns and array of array of Nodes</span>
<span class="keyword">let</span> arrayArray : [[<span class="type">Node</span>&lt;<span class="type">Int</span>&gt;]] = items.<span class="property">compactMap</span>{ $0?.<span class="property">children</span> }

<span class="comment">// assumes same as previous compactMap and issues a warning</span>
<span class="keyword">let</span> arrayArrayWithWarning : [[<span class="type">Node</span>&lt;<span class="type">Int</span>&gt;]] = items.<span class="property">flatMap</span>{ $0?.<span class="property">children</span> }

<span class="comment">// returns flat array of Nodes from children</span>
<span class="keyword">let</span> flatArray = items.<span class="property">flatMap</span>{ $0?.<span class="property">children</span> ?? [<span class="type">Node</span>]() }

<span class="comment">// returns flat array of Nodes from children as well</span>
<span class="keyword">let</span> flatCompactArray = items.<span class="property">compactMap</span>{ $0 }.flatMap{ $0.<span class="property">children</span> }
</code></pre><p>Most importantly, <strong><em>flatMap</em></strong> is not supposed to return a <code>nil</code> (otherwise the compiler assumes it's <strong><em>compactMap</em></strong> and issues a warning). Therefore, you can either use <a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID72">the nil-coalesce operator</a> to return an empty Array or use <strong><em>compactMap</em></strong> beforehand to ensure there will never be <code>nil</code>.</p><h2>flatMap and flattening the Optionals and Generics</h2><p>In this article, you've learned a few key points with regards to <strong><em>flatMap</em></strong> and its relationship to <strong>Generics</strong> and specifically <strong>Optionals</strong>:</p><ul><li>The term <strong><em>flatten</em></strong> in functional programming means to remove a secondary generic into a one-dimensional result such as returning a <code>Value?</code> rather than <code>Value??</code> or <code>[Value]</code> rather than [<code>[Value]]</code></li><li><strong><em>flatMap</em></strong> is to be used when you have an Array of Arrays and wish to flatten those Collections into a simple one-dimensional Array</li><li>Use <strong><em>flatMap</em></strong> when you are returning a result of the same <strong>Generic</strong> type as opposed to map when you are just returning a value such as a <strong>Promise</strong>, <strong>Future</strong>, or <strong>Combine</strong> <strong>Publisher</strong></li><li><strong><em>flatMap</em></strong> is important for <strong>Optionals</strong> in removing **Double Optionals** (i.e. <code>Type??</code>) from your code</li><li><strong>flatMap</strong> is also useful for <strong>Optional</strong> when you are mapping an <strong>Optional</strong> value and **don't need to distinguish between a nil or invalid input value**</li><li><strong><em>compactMap</em></strong> is specifically for the removing nil results from an one-dimensional array</li><li>If a <strong><em>flatMap</em></strong> closure can return nil, return an empty Array instead</li></ul><p>Feel free to reach out if you have any additional questions <a href="https://twitter.com/leogdion">on Twitter <strong>@leogdion</strong></a> or signup for the newsletter below to get the latest tutorials and guides on Swift development.</p></div>
        <span>Tagged with: </span>
      </article>
    </main>
    <footer>
      <div class="address">5859 W Saginaw #182 Lansing MI 48917</div>
      <div class="copyright">© Bright Digit, LLC 2021</div>
    </footer>
  </body>
</html>