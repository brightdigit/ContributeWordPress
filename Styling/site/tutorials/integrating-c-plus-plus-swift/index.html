<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="/css/styles.css"/>
  </head>
  <body>
    <header>
      <nav>
        <ol class="logo">
          <li>
            <a href="/">
              <img src="/media/brightdigit-name.svg"/>
            </a>
          </li>
        </ol>
        <ol class="menu">
          <li>
            <a href="/services">Services</a>
          </li>
          <li>
            <a href="/products">Products</a>
          </li>
          <li>
            <a href="/articles">Articles</a>
          </li>
          <li>
            <a href="/development">Development</a>
          </li>
        </ol>
        <ol class="menu">
          <li>
            <a href="/podcast">Podcast</a>
          </li>
          <li>
            <a href="/newsletters">Newsletters</a>
          </li>
          <li>
            <a href="/sponsorship">Sponsorship</a>
          </li>
          <li>
            <a href="/about">About</a>
          </li>
        </ol>
        <ol class="more">
          <li>
            <a href="/#menu">Menu</a>
          </li>
        </ol>
      </nav>
    </header>
    <main>
      <article>
        <div class="content"><p>In the article <a href="https://learningswift.brightdigit.com/objective-c-and-swift-being-friendly/">Objective-C and Swift - Being Friendly</a>, I talked about how I used Objective-C to integrate C++ libraries with Swift in <a href="https://Speculid.com">Speculid</a>. Today, I'm going to talk about the challenges of using C++ Libraries in your XCode project.</p><p><a href="https://Speculid.com">Speculid is a completely open source application</a> built with the latest version of Xcode (10.1) primarily in Swift (I'll explain why primarily and not only). With Speculid, you <strong>can take a single graphic and build it into a complete App Icon or Image Set.</strong></p><p>Therefore, this meant packaging any required dependencies within the .App package. At first, I thought about including <em>Inkscape</em> and <em>ImageMagick</em> with the installation. However the fact that <em>Inkscape</em> has other dependencies such as <em>XQuartz</em> meant that would be too cumbersome. Therefore, Cairo and librsvg became the obvious choice.</p><img src="https://learningswift.brightdigit.com/wp-content/uploads/sites/2/2018/11/440px-Librsvg.svg_-e1541095349996.png"/><p>{.wp-image-201}<img src="https://learningswift.brightdigit.com/wp-content/uploads/sites/2/2018/11/500px-Cairo_banner_1.svg_-e1541095276942.png"/>{.wp-image-200}</p><h2>Integrating Cairo and librsvg with Swift</h2><p>The first version of Speculid required the installation of two software packages: <a href="https://inkscape.org">Inkscape</a> and <a href="https://www.imagemagick.org">ImageMagick</a>. Each application would be used in some combination to read, manipulate, and export SVG, PNG, JPEG, or PDF files. As a result, <strong>requiring these software packages made the user experience clumsy and difficult.</strong> However, since they are complete applications including both of these packages would be cumbersome as well. That's why I looked into integrating C++ libraries - specifically two of them: <a href="https://cairographics.org"><strong>Cairo</strong></a> <strong>and</strong> <a href="https://developer.gnome.org/rsvg/"><strong>libRSVG</strong></a><strong>.</strong></p><p>Used by several software packages, <strong>Cairo</strong> and <strong>librsvg</strong> are the leading libraries for the development of graphics and SVG manipulation software especially in the open source and Linux communities. <strong>So with Speculid v2.0, I integrated and packaged these libraries as the primary means of reading PNG and SVG and exporting PDF and PNG files</strong>. Above all, both of these libraries can be installed on your Mac through <a href="http://brew.sh"><strong>HomeBrew</strong></a>, using the command:</p><p><code>brew install cairo librsvg</code></p><p>Now we'll need to make sure to copy and link the files.</p><img src="https://learningswift.brightdigit.com/wp-content/uploads/sites/2/2019/01/xe7za0jttem-e1547589614468-1024x513.jpg"/><p>{.wp-image-350}</p><h2>Properly Linking and Copying C++ Libraries</h2><p>[[I]{style="caret-color: #191e23; background-color: #ffffff;"}]{style="color: #191e23;"}n order to use C++ libraries, <strong>we can either compile every piece of C++ code as their individual libraries within Speculid or integrate the already compiled libraries.</strong> At first it seemed compiling the code would be the most clean and efficient way, except for the fact that each library had many requirements as well as special flags for compiling each library. Therefore I decided to take a different route and use the compiled libraries themselves.</p><p>After installing the libraries using HomeBrew, copy the directories for Cairo and librsvg to your project folder. <strong>HomeBrew stores its applications and libraries at:</strong></p><pre><code>/usr/local/<span class="type">Cellar</span>
</code></pre><p>Therefore, <strong>Cairo</strong>, for instance, would be located at:</p><pre><code>/usr/local/<span class="type">Cellar</span>/cairo
</code></pre><p>Once it's copied to your project, there are three spots the files need to be under <strong>build phases:</strong></p><ul><li><strong>Link With Libraries - </strong>all <strong>.dylib</strong> files need to be listed</li><li><strong>Copy Files -</strong> all <strong>.dylib</strong> files need to be copied to the <strong>Frameworks</strong> folder</li><li><strong>Headers -</strong> all <strong>.h</strong> files need to be listed under <strong>Project</strong></li></ul><p><strong>After that, you should be good to go.</strong> If you have any issues with building the application, <strong>double check all the proper files are listed under build phases in your Xcode projec</strong>t.</p><img src="https://learningswift.brightdigit.com/wp-content/uploads/sites/2/2019/01/eiwvoa9zb10-e1547589663680-1024x512.jpg"/><p>{.wp-image-351}</p><h3>Staying Organized in Dependency Hell</h3><p>With your C++ libraries linked and embedded, you run the app and it works without a hitch. So then you archive and package your product and send it off for someone to run and they get something like this:</p><pre><code>dyld: <span class="type">Library</span> not loaded: <span class="keyword">@loader</span> _path/../lib/libintl.<span class="number">8</span>.<span class="property">dylib</span>
</code></pre><p><strong>Unfortunatley libraries like Cairo and librsvg, often have dependencies of their own which are required.</strong> However there are a few commands to help with this:</p><ul><li><code>otool -L</code><br> If we want to find out actual dependencies, this command displays names and version numbers of libraries which are required and used by a particular library.</li><li><code>brew deps —tree</code><br> In order to make sure we have all the dependencies installed on the developer machine, we can use HomeBrew to find their dependencies installed along with the package. Once they are installed we can add them to our project and include them in the App package</li><li><code>install_name_tool</code><br> Once the dependencies are copied and included with our App, we need to update the paths used to look for our dependencies.</li></ul><h4>Gathering Dependencies</h4><p>Firstly we need to make sure we've included all the dependencies in your App by adding the dynamic libraries described by <code>otool -L</code>. For instance if we ran <code>otool -L</code> on the Cairo library we get this:</p><pre><code>$ otool -<span class="type">L</span> libcairo.<span class="number">2</span>.<span class="property">dylib</span>
/usr/local/<span class="type">Cellar</span>/cairo/<span class="number">1.14.12</span>/lib/libcairo.<span class="number">2</span>.<span class="property">dylib</span>:
    /usr/local/opt/cairo/lib/libcairo.<span class="number">2</span>.<span class="dotAccess">dylib</span> (compatibility version <span class="number">11403.0.0</span>, current version <span class="number">11403.12.0</span>)
    /usr/local/opt/pixman/lib/libpixman-<span class="number">1.0</span>.<span class="dotAccess">dylib</span> (compatibility version <span class="number">35.0.0</span>, current version <span class="number">35.0.0</span>)
    /usr/local/opt/fontconfig/lib/libfontconfig.<span class="number">1</span>.<span class="dotAccess">dylib</span> (compatibility version <span class="number">12.0.0</span>, current version <span class="number">12.1.0</span>)
    /usr/local/opt/freetype/lib/libfreetype.<span class="number">6</span>.<span class="dotAccess">dylib</span> (compatibility version <span class="number">22.0.0</span>, current version <span class="number">22.0.0</span>)
    /usr/local/opt/libpng/lib/libpng16.<span class="number">16</span>.<span class="dotAccess">dylib</span> (compatibility version <span class="number">51.0.0</span>, current version <span class="number">51.0.0</span>)
    /usr/lib/libz.<span class="number">1</span>.<span class="dotAccess">dylib</span> (compatibility version <span class="number">1.0.0</span>, current version <span class="number">1.2.11</span>)
    /<span class="type">System</span>/<span class="type">Library</span>/<span class="type">Frameworks</span>/<span class="type">ApplicationServices</span>.<span class="property">framework</span>/<span class="type">Versions</span>/<span class="type">A</span>/<span class="type">ApplicationServices</span> (compatibility version <span class="number">1.0.0</span>, current version <span class="number">50.0.0</span>)
    /usr/lib/libSystem.<span class="type">B</span>.<span class="dotAccess">dylib</span> (compatibility version <span class="number">1.0.0</span>, current version <span class="number">1252.0.0</span>)
    /<span class="type">System</span>/<span class="type">Library</span>/<span class="type">Frameworks</span>/<span class="type">CoreFoundation</span>.<span class="property">framework</span>/<span class="type">Versions</span>/<span class="type">A</span>/<span class="type">CoreFoundation</span> (compatibility version <span class="number">150.0.0</span>, current version <span class="number">1450.16.0</span>)
    /<span class="type">System</span>/<span class="type">Library</span>/<span class="type">Frameworks</span>/<span class="type">CoreGraphics</span>.<span class="property">framework</span>/<span class="type">Versions</span>/<span class="type">A</span>/<span class="type">CoreGraphics</span> (compatibility version <span class="number">64.0.0</span>, current version <span class="number">1129.5.0</span>)
    /<span class="type">System</span>/<span class="type">Library</span>/<span class="type">Frameworks</span>/<span class="type">CoreText</span>.<span class="property">framework</span>/<span class="type">Versions</span>/<span class="type">A</span>/<span class="type">CoreText</span> (compatibility version <span class="number">1.0.0</span>, current version <span class="number">1.0.0</span>)
</code></pre><p>Therefore, we see Cairo requires a few libraries like <em>pixman</em>. Thankfully, <strong>we can get the HomeBrew dependency tree by using the command</strong><br><code>brew deps —tree</code>:</p><pre><code>$ brew deps -tree cairo
fontconfig
freetype
gettext
glib
libffi
libpng
pcre
pixman
</code></pre><p>Thankfully now, if we are missing <em>pixman</em> on our development machine, we can install it using <code>brew install pixman</code> and then copy the HomeBrew cellar directory for <em>pixman</em> to our project folder.</p><p>Again make sure the dynamic libraries are part of the build process under build phases. In other words, you should have something like this under <strong>Build Phases</strong>:</p><img src="https://learningswift.brightdigit.com/wp-content/uploads/sites/2/2018/10/pixman_example.png"/><p>{.wp-image-193}</p><h4>Updating References with <code>install_name_tool</code></h4><p>Now that all the required dependencies are included with the applications, we need to tell Speculid where to look for dependenciesndencies where to look for it's respective dependencies. That's where <code>install_name_tool</code> comes in.</p><h5>Writing a Script to Search and Update Dynamic Libraries</h5><p>So for this process we are going to write a script to update our dependencies, it will need to do the following:</p><ol><li>Look for the dependencies using <code>otool -L</code> which are not system installed</li><li>Update the <em>id</em> of each dynamic library and the path to use @rpath which is the run-time search path the application uses.</li><li>Go through each file in our <code>Frameworks</code> folder and...</li><li>Again update the <em>id</em> as well as the path to use <code>@rpath</code></li><li>Use <code>otool -L</code> to look for each dependency of that dependency</li><li>And update the search path to use <code>@rpath</code></li></ol><p>Here is the result:</p><pre><code>#!/bin/sh

<span class="type">LIBS</span>=`otool -<span class="type">L</span> <span class="string">"$1"</span> | grep <span class="string">"/opt\|Cellar"</span> | awk -<span class="type">F</span>' ' '{ print $1 }'`
<span class="keyword">for</span> lib <span class="keyword">in</span> $LIBS; <span class="keyword">do</span>
  install_name_tool -id <span class="keyword">@rpath</span>/`basename $lib` <span class="string">"`dirname $1`/Frameworks/`basename $lib`"</span>
  install_name_tool -change $lib <span class="keyword">@rpath</span>/`basename $lib` <span class="string">"$1"</span>
done

<span class="type">FRAMEWORKS_FOLDER_PATH</span>=<span class="string">"`dirname $1`/Frameworks/"</span>
deps=`ls <span class="string">"$FRAMEWORKS_FOLDER_PATH"</span> | awk -<span class="type">F</span>' ' '{ print $1 }'`
<span class="keyword">for</span> lib <span class="keyword">in</span> $deps; <span class="keyword">do</span>
  install_name_tool -id <span class="keyword">@rpath</span>/`basename $lib` <span class="string">"`dirname $1`/Frameworks/`basename $lib`"</span>
  install_name_tool -change $lib <span class="keyword">@rpath</span>/`basename $lib` <span class="string">"$1"</span>
  dylib=<span class="string">"`dirname $1`/Frameworks/`basename $lib`"</span>
  deps=`otool -<span class="type">L</span> <span class="string">"$dylib"</span> | grep <span class="string">"/opt\|Cellar"</span> | awk -<span class="type">F</span>' ' '{ print $1 }'`
  <span class="keyword">for</span> dependency <span class="keyword">in</span> $deps; <span class="keyword">do</span>
      install_name_tool -change $dependency <span class="keyword">@rpath</span>/`basename $dependency` <span class="string">"$dylib"</span>
    done
done
</code></pre><p>Let's break this down...</p><h5>Breaking Down Updating Dynamic Libraries</h5><pre><code><span class="type">LIBS</span>=`otool -<span class="type">L</span> <span class="string">"$1"</span> | grep <span class="string">"/opt\|Cellar"</span> | awk -<span class="type">F</span>' ' '{ print $1 }'`
</code></pre><ol><li>Look for the dependencies using <code>otool -L</code> which are not system installed<br> $1 is the path to the executable or <code>${TARGET_BUILD_DIR}/${EXECUTABLE_PATH}</code>. <code>otool -L</code> will list all the dependencies. Piping to grep, we can filter results which are not system installed but in locations like <code>/usr/local/opt</code> are installed via HomeBrew. <code>awk -F' ' '{ print $1 }'</code> will print the results into a format we can use in a for loop.</li></ol><pre><code><span class="keyword">for</span> lib <span class="keyword">in</span> $LIBS; <span class="keyword">do</span>
  install_name_tool -id <span class="keyword">@rpath</span>/`basename $lib` <span class="string">"`dirname $1`/Frameworks/`basename $lib`"</span>
  install_name_tool -change $lib <span class="keyword">@rpath</span>/`basename $lib` <span class="string">"$1"</span>
done
</code></pre><ol start="2"><li>Update the <em>id</em> of each dynamic library and the path to use @rpath which is the run-time search path the application uses.<br> Here we go through each dependency and update the identification name and the path to look for the dependency in our framework to use <code>@rpath</code>.</li></ol><pre><code><span class="type">FRAMEWORKS_FOLDER_PATH</span>=<span class="string">"`dirname $1`/Frameworks/"</span>
deps=`ls <span class="string">"$FRAMEWORKS_FOLDER_PATH"</span> | awk -<span class="type">F</span>' ' '{ print $1 }'`
<span class="keyword">for</span> lib <span class="keyword">in</span> $deps; <span class="keyword">do</span>
</code></pre><ol start="3"><li>Go through each file in our <code>Frameworks</code> folder and...</li></ol><pre><code>   install_name_tool -id <span class="keyword">@rpath</span>/`basename $lib` <span class="string">"`dirname $1`/Frameworks/`basename $lib`"</span>
  install_name_tool -change $lib <span class="keyword">@rpath</span>/`basename $lib` <span class="string">"$1"</span>
</code></pre><ol start="4"><li>Again update the <em>id</em> as well as the path to use <code>@rpath</code></li></ol><pre><code>   dylib=<span class="string">"`dirname $1`/Frameworks/`basename $lib`"</span>
  deps=`otool -<span class="type">L</span> <span class="string">"$dylib"</span> | grep <span class="string">"/opt\|Cellar"</span> | awk -<span class="type">F</span>' '
</code></pre><ol start="5"><li>Use <code>otool -L</code> to look for each dependency of that dependency<br> Calculate the path to the dependency and run <code>otool -L</code> to get its dependencies.</li></ol><pre><code><span class="keyword">for</span> dependency <span class="keyword">in</span> $deps; <span class="keyword">do</span>
      install_name_tool -change $dependency <span class="keyword">@rpath</span>/`basename $dependency` <span class="string">"$dylib"</span>
    done
</code></pre><ol start="6"><li>And update the search path to use <code>@rpath</code></li></ol><p>Now the application and framework should contain all that's needed for our application to run on another machine.</p><p><em>The latest version of the script can be found</em> <a href="https://gist.github.com/leogdion/88516f580108075c8b2d05ab7f895fd0"><em>here</em></a><em>.</em></p><h2>Conclusion</h2><p>Last time we learned <a href="https://learningswift.brightdigit.com/objective-c-and-swift-being-friendly/">how to optimize Objective-C and Swift code so they work well together</a>. Today we learned how to:</p><ul><li>integrate C++ libraries from HomeBrew into our project</li><li>verify all dependencies are included</li><li>fix references using install<em>name</em>tool and a script</li></ul><p>So with Speculid, the Swift code which run the main interface can talk to the Objective-C which interfaces with the C++ libraries. No need for external applications or cumbersome installations.</p><p>If interested check out <a href="https://www.youtube.com/watch?v=SxW5fs7_o18">the presentation I did at Ann Arbor Cocoaheads on this very topic</a>:</p><p>::: {.wp-block-embed_<em>wrapper} https://www.youtube.com/watch?v=SxW5fs7</em>o18 :::</p><p>What are some challenges you face using C++ Libraries? Have you ever using any libraries for an iOS app? Let me know in the comments.</p></div>
        <span>Tagged with: </span>
      </article>
    </main>
    <footer>
      <div class="address">5859 W Saginaw #182 Lansing MI 48917</div>
      <div class="copyright">© Bright Digit, LLC 2021</div>
    </footer>
  </body>
</html>